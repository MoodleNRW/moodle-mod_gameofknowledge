<?php

namespace mod_gameofknowledge\game;

defined('MOODLE_INTERNAL') || die();

use mod_gameofknowledge\game_exception;
use mod_gameofknowledge\state_based_game;

class game_of_knowledge extends state_based_game {

    const DEFAULT_LAYOUT = '
        S Q Q # Q Q S
        Q _ _ Q _ _ Q
        Q _ _ Q _ _ Q
        # Q Q G Q Q #
        Q _ _ Q _ _ Q
        Q _ _ Q _ _ Q
        S Q Q # Q Q S
    ';

    const TYPE_NONE = 'none';
    const TYPE_EMPTY = 'empty';
    const TYPE_START = 'start';
    const TYPE_QUESTION = 'question';
    const TYPE_GOAL = 'goal';

    private $tiles;
    private $activeplayer;
    private $playerlist;

    protected function init_new_game(\stdClass $settings) {
        $this->maxplayers = 0;
        $questionids = []; // TODO

        $layout = self::DEFAULT_LAYOUT;
        $lines = explode("\n", trim($layout));
        $this->tiles = [];
        for ($i = 0; $i < sizeof($lines); $i++) {
            $line = str_replace([' ', "\t"], '', trim($lines[$i]));
            $this->tiles[$i] = [];
            for ($j = 0; $j < strlen($line); $j++) {
                switch ($line[$j]) {
                    case 'S':
                        $this->maxplayers++;
                        $tile = [
                            'type' => self::TYPE_START
                        ];
                        break;

                    case '#':
                        $tile = [
                            'type' => self::TYPE_EMPTY
                        ];
                        break;

                    case 'Q':
                        $tile = [
                            'type' => self::TYPE_QUESTION,
                            'questionid' => array_pop($questionids)
                        ];
                        break;

                    case 'G':
                        $tile = [
                            'type' => self::TYPE_GOAL
                        ];
                        break;

                    default:
                        $tile = [
                            'type' => self::TYPE_NONE
                        ];
                        break;
                }

                $this->tiles[$i][] = $tile;
            }
        }
    }

    protected function find_empty_start_position(): ?string {
        for ($i = 0; $i < sizeof($this->tiles); $i++) {
            for ($j = 0; $j < sizeof($this->tiles[$i]); $j++) {
                if ($this->tiles[$i][$j]['type'] == self::TYPE_START) {
                    $position = $i . '/' . $j;
                    $occupied = false;
                    foreach ($this->playerlist as $player) {
                        if ($player['position'] == $position) {
                            $occupied = true;
                            break;
                        }
                    }
                    if (!$occupied) {
                        return $position;
                    }
                }
            }
        }
        return null;
    }

    protected function init_player(int $player) {
        $position = $this->find_empty_start_position();
        if (!$position) {
            throw new game_exception('noemptystartposition');
        }
        $this->playerlist[$player] = [
            'number' => $player,
            'position' => $position
        ];
    }

    protected function parse_state(array $state)
    {
        $this->tiles = $state['tiles'];
        $this->activeplayer = $state['activeplayer'];
        $this->playerlist = $state['playerlist'];
    }

    public function get_global_state(): array
    {
        return [
            'tiles' => $this->tiles,
            'activeplayer' => $this->activeplayer,
            'playerlist' => $this->playerlist
        ];
    }
    public function get_player_state(int $player): array
    {
        return parent::get_player_state($player); // TODO: Change the autogenerated stub
    }

    public function perform_action(int $player, string $action) {
        global $DB;
        $request = json_decode($action, true, 255, JSON_THROW_ON_ERROR);
        $coordinates = explode('/', $this->playerlist[$player]['position']);
        //check if answor correct;
        if ($coordinates[0] < count($this->tiles[0]) && $this->tiles[$coordinates[0]+1][$coordinates[1]] == $request->questionid) {
            $this->playerlist[$player]['position'] = $coordinates[0]+1 . '/' . $coordinates[1];
        } else if ($coordinates[0] >= 1 && $this->tiles[$coordinates[0]-1][$coordinates[1]] == $request->questionid) {
            $this->playerlist[$player]['position']= $coordinates[0]-1 . '/' . $coordinates[1];
        } else if ($coordinates[1] < count($this->tiles) && $this->tiles[$coordinates[0]][$coordinates[1]+1] == $request->questionid) {
            $this->playerlist[$player]['position'] = $coordinates[0] . '/' . $coordinates[1]+1;
        }  else if ($coordinates[1] >= 1 && $this->tiles[$coordinates[0]][$coordinates[1]-1] == $request->questionid) {
            $this->playerlist[$player]['position'] = $coordinates[0] . '/' . $coordinates[1]-1;
        }

        $this->activeplayer = (count($this->playerlist) == $player) ? 1 : $player++;
    }
}
